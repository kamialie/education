Intro
    > Associative containers - containers in which every element stored inside
        is accessible by a key
    > 4 types in STL:
        - set
        - multiset
        - map
        - multimap
    > bitset???

Set and multiset
    > header <set>
    > signature:
        template <class Key, class Compare = less<Key>, class Allocator = allocator<Key>> class set
        template <class Key, class Compare = less<Key>, class Allocator = allocator<Key>> class multiset
    > parameters:
        - Key - type of key stored inside the set (therefore the type of elements
            themselves)
        - Compare - the type of comparator used to perform a comparison between
            the set elements, in order in ensure strict weak ordering; can be
            implemented as a two-argument function, or functional object,
            less() is default
        - Allocator - type of allocator used to provide storage allocation model
    > set and multiset are associative containers where elements are keys
        themselves
    > strict weak ordering algorithm compares two consecutive elements using
        the second template parameter - Compare; less<Key> uses '<' operator,
        if particular type doesnt not support operation, a custom comparator
        must be created and passed during the set object definition; comparator
        should return true if the element k1 is placed before element k2 (two
        possible prototypes of a comparator:
        template<class Key>
        bool cmp<Key key1, Key key2);

        template<class Key>
        struct CMP {
            bool operator() (Key k1, key k2);
        };)
        If comparator arguments are passed by reference, those references must be
        const - key immutability restriction
        
list of supported operations:
    > constructor
        explicit set (const Compare& copm = Copmare(), const Allocator& = Allocator());
        template <class InputIterator> set (InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator());
        set (const set<Key, Compare, Allocator>& x);
        explicit multiset (const Compare& comp = Compare(), const Allocator& = Allocator());
        template <class InputIterator> multiset (InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator());
        multiset (const multiset<Key, Compare, Allocator>& x);
        - first, last are iterators specifying the range of elements to be inserted
        into container during object creation, x - already existing set object;
        first constructor simply creates an empty set object using optional parameters
        comp and unnamed allocator; second creates set and fills with element
        provided by another collection; third is copy constructor
    > destructor
        ~set()
        ~multiset()
        - destructors of all the stored objects are called and the whole storage
        is released
    > operator=
        set<Key,Compare,Allocator>& operator= (const set<Key,Compare,Allocator>& x);
        multiset<Key,Compare,Allocator>& operator= (const multiset<Key,Compare,Allocator>& x);
        - x is the set object used as the source of the assignment, Key, Compare,
        Allocator are parameters of the template set/multiset class; returns a
        reference to itself(*this)
    
    > begin
        iterator begin();
        const_iterator begin() const;
        - returns an iterator which point to the first element (the key) of the
        set, comes in two variants: const and non-const, but due to key
        immutability there is no difference between them
    > empty
        bool empty() const;
        - returns true if the set is empty
    > size
        size_type size() const;
        - return number of elements currently stored inside set
    > max_size
        size_type max_size() const;
        - returns max physical capacity of the set; might depend on the STL
        library implementation or OS, will always be constant on the same
        environment
    > insert
        pair<iterator, bool> insert(const key_type& x);
        iterator insert(iterator position, const key_type& x);
        void insert(iterator first, iterator last);
        - x is the value to be inserted, position is at which value x should be
        inserted - if chosen properly can result in some optimization;


        
        end, rbegin, rend, empty, size, max_size, insert, erase, clear, swap, find,
        count, lower_bound, upper_bound, equal_range