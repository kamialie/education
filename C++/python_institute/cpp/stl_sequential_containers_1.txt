Intro to Standard Template Library
    > ready to use solutions to many problems; every C++ compiler is accompanied
        with it; can be divided into 2 parts - containers and algorithms;
        - containers
        - algorithms
        - input/output
        - strings
        - numberic library
        - iterators
        - untilities
        - localization
        - regular expressions
        - atomic operations
        - threat support
        - concepts
    > Containers (or collections) - meant to contain smth, simplest example
        is an array (int a[10])
        example -  array - size cannot be changed, doesn't know its own size (must be
            stored in another variable), as a result of previous can not check if
            it is properly accessed, is organized as one memory block
        - vector class is a nutshell template(can work with any type) class
            around simple array; check for its methods later; for example:
                vector <int> v1(10);
                vector <int> v2 = {10, 8, 6, 4};
            [] operator is overloaded, size() returns size...
        split into following categories:
            - sequential containers: vector, list, deque
            - associative containers: set, multiset, map, multimap
            - container adaptors: stack, queue, priority_queue
    > Algorithms - means to transform data(functions); general categorization:
        - non-modifying sequence operations
        - modifying sequence operations
        - sorting
        - set operations
        - binary search
        - heap operations
        - min/max operations
    > Input/output - iosteam, cout...
    > String - sting class (not perfect)
    > Nimeric - for example complex class and valarray type (special type of array
        that allows for specific mathematical operations like slicing)
    > Iterators - generalization of pointers, allow for access to the elements
        of collections; following types:
        - input
        - output
        - forward
        - bidirectional
        - random access
        Are not defined in any manner of specific type (like a class), instead
        defined by their behavior-supported operations; every type of iterator
        has its own set of operations, which must be supported for a particular
        class to be called an iterator
    > Utilities - contains tools that are used to complement containers and
        algorithms, but also can be used int other applications; for example
        date/time manipulation, supporting type pair, etc

Sequence containers
    > conainers maintain certain order to the elemets, can be completely
        controlled by a programmer, containers themselves have no influence
        on the sequence; STL offers 3 solutions: vector, deque, list
    > vector - template class (should specify the type of elemets), which is
        basically a dynamic array, alwasy occupies a continuous memory block,
        biggest advantage is a constant time element access
            #include <vector>
            class A;
            vector<A> v;
        - Constructing vectors - following available constructors(allocator
            parameter is optional in all constructors):
                1. explicit vector (const Allocator & = Allocator());
                2. explicit vector (size_type n, const T& value = T(), const Allocator& = Allocator());
                3. template <class InputIterator> vector (InputIterator first, InputIterator last, const Allocator& = Allocator());
                4. vector (const vector<T, Allocator>& x);
            Second constructor creates a vector of containing n objects, initialized
            to value; Third uses iterators to initialize itself - creates a
            vector with a copy of the values from first (inclusive) to last
            (exclusive) - that is most typical case if creating a new vector
            using the elements from an already existing collection, also possible
            to use normal pointers as iterators (that is normal C++ array can be
            that existing collection); Fourth is a copying constructor - creates
            exact copy from the existing vector
            Implicit type conversion - in the example below vector is of type A,
            meaining it works with objects of A class, push_back() method accepts
            an integer which is further used in implicitly called class A
            constructor (can be avoided by marking constructor explicit):
            #include <vector>
            #include <iosteam>
            using namespace std;
            class A {
                int number;
                public:
                    A (int _number):number(_number) {}
            };
            int main()
            {
                vector<A> v1;
                v1.push_back(1);
                return 0;
            }
            When working with vector of type custom object you should remember
            that push_back() method or anything else that forces vector to be
            reallocated makes use of object's copy constructor to reallocate
            elements; In case of vector assignment (v3 = v2;) the copy constructor
            is called instead of assignment operator(if v3 is empty), if not
            assignment operation is performed
            Vector destructor destroys all objects stored inside itself by calling
            thier destructors and then deallocates all storage - doesn't work
            if elements are pointers (user is responsible); 
    > deque (doube-ended queue) - double-linked list of arrays; no need for
        reallocation, fast insertion from both ends, allows for random access
        using [] operator:
            #include <deque>
            class A;
            deque<A> d;
        Has 4 constructors virtually identical to vector ones; Both vector and
        deque elements must have proper constructor, copy constructor, and
        assignment operator to work as expected
    > list - implements double-linked principle, fast insertions and deletions,
        no [] operator, additional memory consumption to keep linking info

Iterators
    > two most common - random access, bidirectional
    > every container is made up of 4 members (types) related to iterators:
        - iterator - read/write iterator type
        - const_iterator - read-only iterator type
        - reverse_iterator - reverse iterator type
        - const_reverse_iterator - as above read only
        Members have the same names throughout the collections, but are different
        in each container type(for example vector and deque support random access,
        while list supports bidirectional iterators)
    > initialization of iterators - 4 methods that can do that:
        - begin() - returns iterator that point to the first element on the collection
        - end() - returns the iterator that refers to past-the-end-element (for
            collection of n elements return n + 1 element that is non-existant)
        - rbegin() - return last element of the collection
        - rend() - returns iterator that refers to the element before the first
            one
        Each comes in 2 variations, normal and const(const iterator cannot be
        further modified) - for example:
            iterator begin();
            const_iterator begin () const;
    > normal iterator example:
        #include <deque>
        #include <iosteam>
        using namespace std;

        int main() {
            deque <int> d(10);
            
            int i = 1;
            deque<int>::iterator itD = d.begin();
            for (itD = d.begin(); itD != d.end(); ++itD, ++i) {
                *itD = i;
            }
            for (itD = d.begin(); itD != d.end(); ++itD) {
                cout << *itD << " ";
            }
            cout << endl;
            return (0);
        }

Operations(methods)
    > size() - returns number of elements which are currently stored inside
        a collection
    > max_size() - returns maximum physical capacity of a container (depends on
        STL implementation, OS...), is constant in the same environment
    > empty() - returns boolean if container is empty(better choice than size()
        to check if container is empty - faster)
    > resize(size_type sz, T c = T()) - changes the size of a container by
        either causing it to grow or shrink (controlled by sz parameter); sz is
        the exact new size (unsigned)
        - new size is greater than old - new elements are added, which are created
            by copying parameter c, or if not provided by default value
        - deleting extra elements - might cause destructors to be called
    > vector<T>::capacity() - returns total emount of space for elements
        currently allocated for particular vector(usually when reallocation is
        needed, that is capacity() check shows no more available space, new 
        allocation is made as old capacity + 2 for better performance)
    > vector<T>::reserve(size_type n) - n is the minimum value of capacity to be
        requested; method allocates additional space for elements inside a vector,
        if newly requested capacity is greater than current, reallocation is
        enforced (new capacity is at least greater than requested); Used for
        preparing vector to accept new elements and eliminate the need for
        reallocation for each element 
    > access operators:
        - front() - returns reference to the first element in a conainers, might
            be normal or constant; method can become the target if the assignment
            - the l-value
        - back() - same as front(), but returns reference to the last element
        - operator[n] (vector and deque only) - returns reference to the element
            of index n; valid range - 0 to (size - 1); accessed element can be
            used as l-value and r-value; doesn't check for proper range, can
            only change an already stored element, thus cant change the size of
            the container
        - at(n) (vector and deque only) - returns reference element to the element
            of index n; the only difference with [] operator is check for valid
            range - if fails exception is thrown
    > assign(size_type n, const T& u)
        assign(InputIterator first, InputIterator second) - first, second are
            input operators that provide a collection - assign will copy all
            element from range, including first, excluding last; n - number
            of element, u - value to be copied; the whole old container is 
            dropped and deleted, as a result it's possible to have source and
            target containers of diffirent size, resulting size is dictated
            by parameters; in both cases new elements are obtained by
            copying the source values
    > iterator insert(iterator position, const T& x)
        insert(iterator position, size_type n, const T& x)
        insert(iterator position, InputIterator first, InputIterator last) -
            position - the postion in the container at whick the insertion of
            an element(or elements) to be performed (for deque and vector this is
            RandomAccessIterator, for list this is BidirectionalIterator),
            x - the value to be inserted, n - the number of x values to be
            inserted, first, last - specify range of iterators to be inserted;
            vector - if reallocation is needed, all references and iterator are
            invalidated, deque - same as vector, unless insertion at the beginning,
            or end, list - iterators and references remain the same 
    > iterator erase(iterator position)
        iterator erase(iterator first, iterator last) - returns iterator to the
            first element after the last removed or end if last element of the
            collection is removed; during the removal the of the element
            destructors are called
    > void vector::swap(vector<T, Allocator>& vec)
        void deque::swap(deque<T, Allocator>& dqe)
        void list::swap(deque<T, Allocator>& lst) - vec, dqe, lst - another
            collection of the same type as this one; swaps entire content between
            two collections of the same type, sizes may differ; after swap all
            existing iterators are still valid, but point to different containers
    > void clear() - removes all elements and sets size to 0, during removal
        destructors are called
    > void push_back(const T& x) - x is the value which will be used to create
        a new element (by copying) inside a container; adds a value to the end
        of the conainer and increases the size by one, however different
        containers react differently:
        - vector - is has enough capacity, no reallocation is performed
        - deque - all iterators are invalidated
        - list - all iterators are left unaffected
    > void pop_back() - removes an element from the tail of the container
        (destructor is called); in case of vector all iterators, pointers and
        references referring to element are invalidated
    > void push_front(const T& x) (deque and list only) - same as push_back, but adds
        element to the beginning, in case of deque all iterators are invalidated,
        list - left unaffected
    > void pop_front() - same as pop_back(), but removes element at the beginning
    > void slice(iterator position, list<T, Allocator>& x)
        void slice(iterator position, list<T, Allocator>& x, iterator i)
        void slice(iterator position, list<T, Allocator>& x, iterator first, iterator last)
        - (list) moves elements from list x to target list; target list size
            increases, while parameter list decreases; 3 version are as follows:
            moves whole content, moves only one element, moves a range of elements;
            no destruction or construction takes place
    > void remove (const T& value) (list only) - value is the value to be removed
        from the list, type is the same as declared in list; removes all entries
        equal to the value provided, destructors are called
    > void remove_if(Predicate pred) (list only) - pred is a unary predicate
        (one argument function or function object) which takes an argument of the
        same type as the elements in the list; predicate should return true for
        elements to be removed
    > void unique() (list only)
        void unique(BinaryPredicate binary_pred) (list only) - binary_pred is 
            two-argument function or proper functional object, which performs
            comparison between two elements of the list - if second is alike,
            it is deleted; function removes consecutive duplicate elements by
            comparing two directly subsequent elements; to supply a predicate 
            must use either function pointer or the functional object instance
    > void merge(list<T, Allocator>& x) (list only)
        void merge(list<Allocator>& x, Compare comp) - x is a source list, whose
            elements are to be merged into calling list, comp is a binary
            predicate used to compare elements from source and target lists to
            ensure proper sequence of elements in target list; method performs
            a merge of two sorted lists - two iterators are used: source and target;
            method compares objects' pointers with those iterators and if source
            object is less than target object is removed from source and place
            at target iterators position, otherwise target iterator advances,
            procedure continues until target iterator reaches the end(), at that
            moment if anything left in source, it is all placed at the end of
            target list; no object creation, copy, or deletion takes place, both
            list have to be sorted first; second version uses external comparator
            in the form of binary predicate, first argument is an object from
            target list and the second is element from the source, returns true
            if target is less than the source(should perform the strictly weak
            strict ordering)
    > void sort() (list only)
        void sort(Compare comp) - performs sorting elements in lexicographic order
        (lowest to highest), first version uses < operator to compare two elements,
        in order to use other type need to create the operator for those type or
        create a binary predicate; must perform strict weak ordering, during
        the sort object are only moved
    > void reverse() (list only) - reverses the order in list conainer

Container adaptors
    > in STL terminology conainer adaptor is a class which uses STL conainer in
        order to provide other functionality, STL provides 3:
        - stack
        - queue
        - priority_queue
    > for adaptors to work, you need to provide a proper object container,
        can use default one or any class that provides interface required by
        conainer adaptor
    > stack
        (signature - template <class T, class Container = deque<T>> class stack)
        LIFO concept, requires(storage container to have) following interface:
            - back()
            - push_back()
            - pop_back()
        any sequential containers(vector, deque, list) can be used, default is
        deque
        explicit stack(const Container& cont = Container())
            stack(const stack& other) - stack constructors, where cont is a
                container provided to serve as an internal storage, must be the
                same type as type defined in stake template, other is an already
                existing stack which is sued as template to instantiate the current
                object; first constructor creates a stack using the internal
                container provided, container doesnt have to be empty, second is
                copying constructor, in both cases source stack and the stack
                being created must be internal storage of the same type 
        stack<T, Container>& operator=(const stack<T, Container>& other) -
            assignment operator; other - source stack object, whose contents are
            copied and stored in the target stack(both must have the same type
            internal container), returns reference to a calling object(*this)
        ~stack() - destructor, calls destructors (if applicable) of all objects
            stored inside the stack, and deallocates all used storage
        bool empt() const - tests if size if zero, is just a proxy which calls
            the method of the same name iin underlying container
        size_type size() const - returns number of currently stored elements
            inside stack, is a proxy
        value_type& top()
            const value_type& top () const - returns a reference to the element
                at the top of the stack, is a proxy which calls back() method
                of an underlying container
        void push(const T& x) - x is the value to be pushed(copied) onto top of
            the stack, proxy which called push_back() of underlying container
        void pop() - removes top most element, proxy that calls top() pop_back()
            method, doesnt return anything
    > queue
        (signature - template <class T, class Container = deque<T>> class queue)
        FIFO, requires(storage container to have) following interface:
            - front()
            - back()
            - push_back()
            - pop_front()
        deque and list can be used, deque is default
        explicit queue(const Container& cont = Container())
            queue(const queue& other) - same as stack constructors, rule about
                same type of internal storage container applies as well
        ~queue() - same as stack destructor
        queue<T, Contrainer>& operator=(const queue<T, Container>& other) -
            assignment operator same as stack
        bool empty(), size_type size() const - same as stack
        value_type& front()
            const value_type& front() const - returns reference to the first 
                element at the front of a queue, this is the element that has
                been the longest in the queue, it can be popped; is a proxy
                to front() method of the underlying container
        value_type& back()
            const value_type& back() const - same as front, but last element;
                cannot be removed
        void push(const T& x) - adds new element, thus increases total size,
            after previously pushed element, new element is created y copying
            a parameter x; proxy to call push_back() method
        void pop() - remove the first element, proxy to pop_front() method
    > priority_queue
        (signature - template <class T, class Container = vector<T>, class Compare = less<typename Container::value_type>> class priority_queue)
        parameters:
            - T - the type of elements stored
            - Container - internar storage container
            - Compare - comparator used for ascertaining the strict weak ordering
                inside the priority_queue
            - Container::value_type - type of the elements stored inside the
                priority_queue - it holds the same meaning as T
        Data stucture in which the greatest element is alwasy the first one, due
            to some predifined strict weak ordering condition, requires internal
            storage to have the following methods:
                - elements must be accessible through the random access iterator
                - front()
                - push_back()
                - pop_back()
            Only vector and deque are applicable, vector is default; maintains
            order using comparator - is a function that takes 2 paramters and
            returns true if first parameter is lower than the second, can be
            implemented as either a functional object or a standalone method,
            comparator is used when a new element is inserted into the queue
            or removed to guarantee that the element on top is always the greatest;
            if non specified, STL predicate is used; ordered sequence is achieved
            by using the heap algorithm:
                - make_heap()
                - push_heap()
                - pop_head()
        explicit priority_queue(const Compare& x = Compare(), const Container& y = Contrainer())
            priority_queue(const priority_queue& other) - constructor, parameters:
                - x - comparator oject used to ensure strict weak ordering, must
                    be the same type as the template parameters
                - y - container provided to serve as internal storage
                - other - already existing priority_queue used as a template to
                    instantiate the current object
                constructor creates priority_queue using the internal container
                provided and compares the predicate, container doesnt have to be
                empty; if x and y are provided their copies are created, in other
                cases the container and comparator are just initialized, then
                constructor calls make_heap()
        ~priority_queue() - destroys priority_queue object, calls (if applicable)
            destructors of all objects stored inside, then deallocates used
            storage
        priority_queue<T, Container>& operator=(const priority_queue<T, Container>& other)
            - returns a reference to a calling object (*this); assingment operator
            copies the elements from other and place them in a calling object
            (l-value); both must have same type internal storage
        bool empty() const, size_type size() const - same as before, proxy methods
            to call internal containers methods
        const value_type& top() const - returns a constant reference to the
            element at the top of a priority_queue, returns a const not to be
            able to modify it - would disrupt the order of the queue; it a proxy
            method calling front() of the underlying container
        void push(const T& x) - is copied and inserted based on already existing
            elements, proxy calling push_back(), afterwards push_heap() is called
        void pop() - removes the top-most element from priority_queue(greatest
            element), proxy to call pop_heap() algorithm then pop_back()