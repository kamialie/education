Intro to Standard Template Library
    > ready to use solutions to many problems; every C++ compiler is accompanied
        with it; can be divided into 2 parts - containers and algorithms;
        - containers
        - algorithms
        - input/output
        - strings
        - numberic library
        - iterators
        - untilities
        - localization
        - regular expressions
        - atomic operations
        - threat support
        - concepts
    > Containers (or collections) - meant to contain smth, simplest example
        is an array (int a[10])
        example -  array - size cannot be changed, doesn't know its own size (must be
            stored in another variable), as a result of previous can not check if
            it is properly accessed, is organized as one memory block
        - vector class is a nutshell template(can work with any type) class
            around simple array; check for its methods later; for example:
                vector <int> v1(10);
                vector <int> v2 = {10, 8, 6, 4};
            [] operator is overloaded, size() returns size...
        split into following categories:
            - sequential containers: vector, list, deque
            - associative containers: set, multiset, map, multimap
            - container adaptors: stack, queue, priority_queue
    > Algorithms - means to transform data(functions); general categorization:
        - non-modifying sequence operations
        - modifying sequence operations
        - sorting
        - set operations
        - binary search
        - heap operations
        - min/max operations
    > Input/output - iosteam, cout...
    > String - sting class (not perfect)
    > Nimeric - for example complex class and valarray type (special type of array
        that allows for specific mathematical operations like slicing)
    > Iterators - generalization of pointers, allow for access to the elements
        of collections; following types:
        - input
        - output
        - forward
        - bidirectional
        - random access
        Are not defined in any manner of specific type (like a class), instead
        defined by their behavior-supported operations; every type of iterator
        has its own set of operations, which must be supported for a particular
        class to be called an iterator
    > Utilities - contains tools that are used to complement containers and
        algorithms, but also can be used int other applications; for example
        date/time manipulation, supporting type pair, etc

Sequence containers
    > conainers maintain certain order to the elemets, can be completely
        controlled by a programmer, containers themselves have no influence
        on the sequence; STL offers 3 solutions: vector, deque, list
    > vector - template class (should specify the type of elemets), which is
        basically a dynamic array, alwasy occupies a continuous memory block,
        biggest advantage is a constant time element access
            #include <vector>
            class A;
            vector<A> v;
        - Constructing vectors - following available constructors(allocator
            parameter is optional in all constructors):
                1. explicit vector (const Allocator & = Allocator());
                2. explicit vector (size_type n, const T& value = T(), const Allocator& = Allocator());
                3. template <class InputIterator> vector (InputIterator first, InputIterator last, const Allocator& = Allocator());
                4. vector (const vector<T, Allocator>& x);
            Second constructor creates a vector of containing n objects, initialized
            to value; Third uses iterators to initialize itself - creates a
            vector with a copy of the values from first (inclusive) to last
            (exclusive) - that is most typical case if creating a new vector
            using the elements from an already existing collection, also possible
            to use normal pointers as iterators (that is normal C++ array can be
            that existing collection); Fourth is a copying constructor - creates
            exact copy from the existing vector
            Implicit type conversion - in the example below vector is of type A,
            meaining it works with objects of A class, push_back() method accepts
            an integer which is further used in implicitly called class A
            constructor (can be avoided by marking constructor explicit):
            #include <vector>
            #include <iosteam>
            using namespace std;
            class A {
                int number;
                public:
                    A (int _number):number(_number) {}
            };
            int main()
            {
                vector<A> v1;
                v1.push_back(1);
                return 0;
            }
            When working with vector of type custom object you should remember
            that push_back() method or anything else that forces vector to be
            reallocated makes use of object's copy constructor to reallocate
            elements; In case of vector assignment (v3 = v2;) the copy constructor
            is called instead of assignment operator(if v3 is empty), if not
            assignment operation is performed
            Vector destructor destroys all objects stored inside itself by calling
            thier destructors and then deallocates all storage - doesn't work
            if elements are pointers (user is responsible); 
    > deque (doube-ended queue) - double-linked list of arrays; no need for
        reallocation, fast insertion from both ends, allows for random access
        using [] operator:
            #include <deque>
            class A;
            deque<A> d;
        Has 4 constructors virtually identical to vector ones; Both vector and
        deque elements must have proper constructor, copy constructor, and
        assignment operator to work as expected
    > list - implements double-linked principle, fast insertions and deletions,
        no [] operator, additional memory consumption to keep linking info

Iterators
    > two most common - random access, bidirectional
    > every container is made up of 4 members (types) related to iterators:
        - iterator - read/write iterator type
        - const_iterator - read-only iterator type
        - reverse_iterator - reverse iterator type
        - const_reverse_iterator - as above read only
        Members have the same names throughout the collections, but are different
        in each container type(for example vector and deque support random access,
        while list supports bidirectional iterators)
    > initialization of iterators - 4 methods that can do that:
        - begin() - returns iterator that point to the first element on the collection
        - end() - returns the iterator that refers to past-the-end-element (for
            collection of n elements return n + 1 element that is non-existant)
        - rbegin() - return last element of the collection
        - rend() - returns iterator that refers to the element before the first
            one
        Each comes in 2 variations, normal and const(const iterator cannot be
        further modified) - for example:
            iterator begin();
            const_iterator begin () const;
    > normal iterator example:
        #include <deque>
        #include <iosteam>
        using namespace std;

        int main() {
            deque <int> d(10);
            
            int i = 1;
            deque<int>::iterator itD = d.begin();
            for (itD = d.begin(); itD != d.end(); ++itD, ++i) {
                *itD = i;
            }
            for (itD = d.begin(); itD != d.end(); ++itD) {
                cout << *itD << " ";
            }
            cout << endl;
            return (0);
        }

Operations(methods)
    > size() - returns number of elements which are currently stored inside
        a collection
    > max_size() - returns maximum physical capacity of a container (depends on
        STL implementation, OS...), is constant in the same environment
    > empty() - returns boolean if container is empty(better choice than size()
        to check if container is empty - faster)
    > resize(size_type sz, T c = T()) - changes the size of a container by
        either causing it to grow or shrink (controlled by sz parameter); sz is
        the exact new size (unsigned)
        - new size is greater than old - new elements are added, which are created
            by copying parameter c, or if not provided by default value
        - deleting extra elements - might cause destructors to be called
    > vector<T>::capacity() - returns total emount of space for elements
        currently allocated for particular vector(usually when reallocation is
        needed, that is capacity() check shows no more available space, new 
        allocation is made as old capacity + 2 for better performance)
    > vector<T>::reserve(size_type n) - n is the minimum value of capacity to be
        requested; method allocates additional space for elements inside a vector,
        if newly requested capacity is greater than current, reallocation is
        enforced (new capacity is at least greater than requested); Used for
        preparing vector to accept new elements and eliminate the need for
        reallocation for each element 
    > access operators:
        - front() - returns reference to the first element in a conainers, might
            be normal or constant; method can become the target if the assignment
            - the l-value
        - back() - same as front(), but returns reference to the last element
        - operator[n] (vector and deque only) - returns reference to the element
            of index n; valid range - 0 to (size - 1); accessed element can be
            used as l-value and r-value; doesn't check for proper range, can
            only change an already stored element, thus cant change the size of
            the container
        - at(n) (vector and deque only) - returns reference element to the element
            of index n; the only difference with [] operator is check for valid
            range - if fails exception is thrown
    > assign(size_type n, const T& u)
        assign(InputIterator first, InputIterator second) - first, second are
            input operators that provide a collection - assign will copy all
            element from range, including first, excluding last; n - number
            of element, u - value to be copied; the whole old container is 
            dropped and deleted, as a result it's possible to have source and
            target containers of diffirent size, resulting size is dictated
            by parameters; in both cases new elements are obtained by
            copying the source values
    > iterator insert(iterator position, const T& x)
        insert(iterator position, size_type n, const T& x)
        insert(iterator position, InputIterator first, InputIterator last) -
            position - the postion in the container at whick the insertion of
            an element(or elements) to be performed (for deque and vector this is
            RandomAccessIterator, for list this is BidirectionalIterator),
            x - the value to be inserted, n - the number of x values to be
            inserted, first, last - specify range of iterators to be inserted;
            vector - if reallocation is needed, all references and iterator are
            invalidated, deque - same as vector, unless insertion at the beginning,
            or end, list - iterators and references remain the same 
    > iterator erase(iterator position)
        iterator erase(iterator first, iterator last) - returns iterator to the
            first element after the last removed or end if last element of the
            collection is removed; during the removal the of the element
            destructors are called
    > void vector::swap(vector<T, Allocator>& vec)
        void deque::swap(deque<T, Allocator>& dqe)
        void list::swap(deque<T, Allocator>& lst) - vec, dqe, lst - another
            collection of the same type as this one; swaps entire content between
            two collections of the same type, sizes may differ; after swap all
            existing iterators are still valid, but point to different containers
    > void clear() - removes all elements and sets size to 0, during removal
        destructors are called
    > void push_back(const T& x) - x is the value which will be used to create
        a new element (by copying) inside a container; adds a value to the end
        of the conainer and increases the size by one, however different
        containers react differently:
        - vector - is has enough capacity, no reallocation is performed
        - deque - all iterators are invalidated
        - list - all iterators are left unaffected
    > void pop_back() - removes an element from the tail of the container
        (destructor is called); in case of vector all iterators, pointers and
        references referring to element are invalidated
    > void push_front(const T& x) (deque and list only) - same as push_back, but adds
        element to the beginning, in case of deque all iterators are invalidated,
        list - left unaffected
    > void pop_front() - same as pop_back(), but removes element at the beginning
    > void slice(iterator position, list<T, Allocator>& x)
        void slice(iterator position, list<T, Allocator>& x, iterator i)
        void slice(iterator position, list<T, Allocator>& x, iterator first, iterator last)
        - (list) moves elements from list x to target list; target list size
            increases, while parameter list decreases; 3 version are as follows:
            moves whole content, moves only one element, moves a range of elements;
            no destruction or construction takes place
        