Intro to Standard Template Library
    > ready to use solutions to many problems; every C++ compiler is accompanied
        with it; can be divided into 2 parts - containers and algorithms;
        - containers
        - algorithms
        - input/output
        - strings
        - numberic library
        - iterators
        - untilities
        - localization
        - regular expressions
        - atomic operations
        - threat support
        - concepts
    > Containers (or collections) - meant to contain smth, simplest example
        is an array (int a[10])
        example -  array - size cannot be changed, doesn't know its own size (must be
            stored in another variable), as a result of previous can not check if
            it is properly accessed, is organized as one memory block
        - vector class is a nutshell template(can work with any type) class
            around simple array; check for its methods later; for example:
                vector <int> v1(10);
                vector <int> v2 = {10, 8, 6, 4};
            [] operator is overloaded, size() returns size...
        split into following categories:
            - sequential containers: vector, list, deque
            - associative containers: set, multiset, map, multimap
            - container adaptors: stack, queue, priority_queue
    > Algorithms - means to transform data(functions); general categorization:
        - non-modifying sequence operations
        - modifying sequence operations
        - sorting
        - set operations
        - binary search
        - heap operations
        - min/max operations
    > Input/output - iosteam, cout...
    > String - sting class (not perfect)
    > Nimeric - for example complex class and valarray type (special type of array
        that allows for specific mathematical operations like slicing)
    > Iterators - generalization of pointers, allow for access to the elements
        of collections; following types:
        - input
        - output
        - forward
        - bidirectional
        - random access
        Are not defined in any manner of specific type (like a class), instead
        defined by their behavior-supported operations; every type of iterator
        has its own set of operations, which must be supported for a particular
        class to be called an iterator
    > Utilities - contains tools that are used to complement containers and
        algorithms, but also can be used int other applications; for example
        date/time manipulation, supporting type pair, etc

Sequence containers
    > conainers maintain certain order to the elemets, can be completely
        controlled by a programmer, containers themselves have no influence
        on the sequence; STL offers 3 solutions: vector, deque, list
    > vector - template class (should specify the type of elemets), which is
        basically a dynamic array, alwasy occupies a continuous memory block,
        biggest advantage is a constant time element access
            #include <vector>
            class A;
            vector<A> v;
        - Constructing vectors - following available constructors(allocator
            parameter is optional in all constructors):
                1. explicit vector (const Allocator & = Allocator());
                2. explicit vector (size_type n, const T& value = T(), const Allocator& = Allocator());
                3. template <class InputIterator> vector (InputIterator first, InputIterator last, const Allocator& = Allocator());
                4. vector (const vector<T, Allocator>& x);
            Second constructor creates a vector of containing n objects, initialized
            to value; Third uses iterators to initialize itself - creates a
            vector with a copy of the values from first (inclusive) to last
            (exclusive) - that is most typical case if creating a new vector
            using the elements from an already existing collection, also possible
            to use normal pointers as iterators (that is normal C++ array can be
            that existing collection); Fourth is a copying constructor - creates
            exact copy from the existing vector
            Implicit type conversion - in the example below vector is of type A,
            meaining it works with objects of A class, push_back() method accepts
            an integer which is further used in implicitly called class A
            constructor (can be avoided by marking constructor explicit):
            #include <vector>
            #include <iosteam>
            using namespace std;
            class A {
                int number;
                public:
                    A (int _number):number(_number) {}
            };
            int main()
            {
                vector<A> v1;
                v1.push_back(1);
                return 0;
            }
            When working with vector of type custom object you should remember
            that push_back() method or anything else that forces vector to be
            reallocated makes use of object's copy constructor to reallocate
            elements; In case of vector assignment (v3 = v2;) the copy constructor
            is called instead of assignment operator(if v3 is empty), if not
            assignment operation is performed
            Vector destructor destroys all objects stored inside itself by calling
            thier destructors and then deallocates all storage - doesn't work
            if elements are pointers (user is responsible); 
    > deque (doube-ended queue) - double-linked list of arrays; no need for
        reallocation, fast insertion from both ends, allows for random access
        using [] operator:
            #include <deque>
            class A;
            deque<A> d;
        Has 4 constructors virtually identical to vector ones; Both vector and
        deque elements must have proper constructor, copy constructor, and
        assignment operator to work as expected
    > list - implements double-linked principle, fast insertions and deletions,
        no [] operator, additional memory consumption to keep linking info

Iterators
    > two most common - random access, bidirectional
    > every container is made up of 4 members (types) related to iterators:
        - iterator - read/write iterator type
        - const_iterator - read-only iterator type
        - reverse_iterator - reverse iterator type
        - const_reverse_iterator - as above read only
        Members have the same names throughout the collections, but are different
        in each container type(for example vector and deque support random access,
        while list supports bidirectional iterators)
    > initialization of iterators - 4 methods that can do that:
        - begin() - returns iterator that point to the first element on the collection
        - end() - returns the iterator that refers to past-the-end-element (for
            collection of n elements return n + 1 element that is non-existant)
        - rbegin() - return last element of the collection
        - rend() - returns iterator that refers to the element before the first
            one
        Each comes in 2 variations, normal and const(const iterator cannot be
        further modified) - for example:
            iterator begin();
            const_iterator begin () const;
    > normal iterator example:
        #include <deque>
        #include <iosteam>
        using namespace std;

        int main() {
            deque <int> d(10);
            
            int i = 1;
            deque<int>::iterator itD = d.begin();
            for (itD = d.begin(); itD != d.end(); ++itD, ++i) {
                *itD = i;
            }
            for (itD = d.begin(); itD != d.end(); ++itD) {
                cout << *itD << " ";
            }
            cout << endl;
            return (0);
        }