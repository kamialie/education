Pointers
    > pointers are used to store information about the location (address) of any
        other data
    > int *p; - declaring a pointer to data of type int
    > C++ syntax doesnt allow to assign integer literal to pointer (pointer = 1234)
    > p = 0; null pointer (or p = NULL, include cstring header or any other
        which includes it, for example iostream does)
    > p &i; - assign address of a variable
    > i = *p; - dereferencing - operator where the pointer variable becomes
        synanymous with the value it points to
    > sizeof - operator (unary prefix) that provides info on how many bytes of
        memory its argument occupies or may occupy; takes variables, literals
        and types as its argument; may not use parethesis, if argument is a value
        or literal, but have to for types

Pointers vs arrays
    > name of array without indices is a synonym of teh pointer pointing to the
        first element of an array
    > meaningful and possible pointer operations:
        - adding an integer (integer is multiplied by type size)
        - subtracting an integer (same as previous)
        - subtracting pointer from a pointer (result is divided by type size)
        - comparing two pointers

Functions
    > type_of_result function_name(parameters_with_type); - function declaration;
        alongside function body forms function definition
    > return does two things:
        - indicates which value is returned
        - terminates the execution
    > function declaration must be placed before first invocation; function
        definition can be placed after invocation; parameter names can be ommitted

Declaring and defining functions
    > declaration:
        - return type defaults to int; void meains nothing
        - can have more than one function of the same name - overloading
        - void in parameter list endicates no parameters, every parameter has to
            have a type in front of it
    > definition
        - return; - can be placed in void function; it is assumed that the
            return statement is implicitly executed within the void function's
            body
        - void function's result can't be assigned to a variable, thus the only
            acceptable invocation form is the folowing:
                VoidFunction();

Transferring data to and from functions
    > global variable - declated outside any function, thus accessible by all
        functions declared in the same source file after variable declaration
    > functions can modify a global variable - that is called side effect
    > passing parameter by value:
        - formal parameter doesn't change actual parameter's value, as the later
            only provides the value
    > passing parameter by reference:
        - void function(int &parameter); - declare passing by reference in
            function definition
        - every modification made into a formal parameter will affect actual
            parameter
        - corresponding actual parameter must be a variable - cant be expression
            or other function invocation result
    > 'C language' way of passing by reference - pass pointer to a variable

Default parameters
    > default parameter declaration:
        type function (type parameter = value){} - default is used when actual
            parameter is ommitted
    > non-default parameters must be coded first
    > parameters are assigned in the same order as they appear - thus cant assign
        default value for first and explicit value for the second

Inline functions
    > each function's code has to be supplemented with two elements:
        - prologue - implicitly executed before the function; transfers
            parameters from the invoker's code to function's stack
        - epilogue - implicitly executed after the function; transfers the
            result of the function and clears the stack
    > inline function - is written by compiler on every invocation (speeds up
        the program, good for short functions); can put inline either before or
        after type, in definition or declaration or both

Overloading
    > same name can be used for multiple functions, but must be distiguishable to
        the compiler:
        - number of parameters
        - parameter's types
    > return type isn't taken into account
    > 1.0 is literal of type double, thus if two overloading functions have int
        and float, compiler can't promote double to float (more precision to
        less one) and will cause a compilation error (won't find the best candidate)
    > ternary ? operator:
        expr1 ? expr2 : expr3 - 1 is evaluated, if result is non-zero 2 is returned,
            otherwise 3

Sorting

Memory on demand
    > void *ptr - amorphous pointer - can point to anything; can later be casted
        to other type; can't be dereferenced
    > new keyword:
        - needs precise specifications regarding the entity being created - type
            description and size if an array:
                float *array = new float[20];
                int count = new int;
        - returns a pointer of type conforming to the newly created entity
        - doesn't feel the memory area (garbage)
    > delete keyword:
        - 'delete []' for arrays, just 'delete' for everything else:
            delete [] array;
            delete count;
        - can only release entire block
        - all the pointer that were pointing to the memory area become illegal