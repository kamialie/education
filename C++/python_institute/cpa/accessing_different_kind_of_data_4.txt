Arrays of pointers
    > int **ptr - declaring pointer to a pointer to int
    > ptr[i][j] same as *(*(ptr + i) + j)

Conversions
    > the act of changing the nature of the data without (if possible) changing
        its value:
    > automatic conversion - compiler knows where they need to be applied and applies
        them without asking (also called implicit conversion)
        - value is a part of a complex expression built of many values of
            different types
        - values plays a role of a logical condition within if, while, do...
            for example, if (double) has to be converted to int first
        - subject to assignment:
            1. change the value of a variable - Float = 1;
            2. set the value of a formal parameter  - fun(Float); - actual
                parameter of type float is converted to into formal parameter of
                type int
            3. specify the return value of a function - return -1; return type is
                float, thus int is first converted to float
    > explicit conversion - performed by developer using special syntax (also called
        typecasting)
        - C-style casting - (new_type)expression
        - functional notation - new_type(expression) - does the same as previous,
            when applied to standard(basic) types, but can also be applied to
            objects and have more than one value
    > when bigger is converted to smaller - most likely will get biggest on
        negative side, since all bits will be turned on
    > Promosion - conversion of the data taking part in an evaluation to safest
        type; conducted according following rule in the order below until all
        data in expression has the same type
        1. integer promotion - char and short to int
        2. floating point - float to double
        3. if there is a double, the rest is converted to double
        4. if there is a long int, the rest is converted to long int
        If the context requires another type than the resulting from conversions,
            than will be the last conversion

Strings - the basics
    > #include <string> - have to include, since string isn't a built-in type
        (string is not a keyword)
    > string PetName = "Lassie"; - string initialization; are enclosed in quotes
        (apostrophes for characters)
    > string PetName("Lassie"); - another way to initialize
    > '+' operator - concatenates strings; can not concatenate two literals
        (that is string str = "A" + "B"), at least one operand must be variable;
        can be used as shortcut
    > cin stream will treat any whitespace character as a delimiter, thus only
        first word will be saved
    > getline(cin, variable) - function that takes input as a whole and sends to
        the variable (including whitespaces)
    > comparing strings:
        1. == - check if two strings are identical
        2. >, <, >=, <=, != - can compare in alphabetical order among other things
        3. objective approach (call methods):
            - object.compare(str) - checks of two strings are identical, if so,
                returns 0; '>' - means object > string, '<' - object < string

String - continued
    > newstr = oldstr.substr(start, length) - create a new string that is a
        substring of another string, second parameter inclusive, ommiting second
        defaults to covering all remaining chars; no params - copy original;
        substring must be legal - wholly fit inside original
    > get length of a string (characters containing):
        - int size = s.size();
        - int length = s.length();
    > s.compare(start, length, other_string) - compares other_string as a whole
        to a substring made by first 2 parameters; 0 for identical strings, -1 -
        other is greater, 1 - vice versa
    > s.compare(start, length, other_string, other_start, other_length) - more
        detailed comparison
    > int where_it_start = s.find(another_str, start) - start defaults to zero,
        another_str can a single character; on fail returns string::npos:
            if (where_it_start != string::npos)
    > int currently_used = s.capacity() - the size of the currently allocated
        buffers
    > int not_more_than = s.max_size() - max possible size of a string in the
        system
    > s.reserve(integer) - controls the size of buffer allocated for string;
        content is immune, allocated memory is rounded based on system requirements
        (as well as initialization)
    > s.clear() - removes all characters
    > s.resize(integer, 'char') - if int > s.length, string is expanded ('\0' is
        default, can specify by second parameter), otherwise, string is truncated
    > s.empty() - returns bool, whiether strings has character or not

Strings - temporary summation
    > str.append(other_str, start, length) - append substring of a string; if last
        two parameters are ommitted the whole string is appended
    > str.append(integer, char) - appends specified char integer times; append
        method also returns new string
    > str.push_pack(char) - append character
    > str.insert(location_index, str2) - insert method, 3rd and 4th arguments
        can specify substring to insert based on str2 parameter(index, length)
    > str.insert(location_index, int_times, char) - insert char, second param
        specifies how many times
    > str.assign(int_times, char) - assigns completely new value
    > str.replace(start, length, str2, start_sub, length_sub) - last 2 params
        can be ommitted to use the whole str2
    > str.erase(start, length) - remove substring; start defaults to 0, length -
        to original length
    > str.swap(str2) - swaps contents of variables(swaps pointers to strings)

Name spaces
    > cout and endl are part of std namespace
    > '::' - scope resolution operator, qualifies names and binds them with their
        homespace:
            home_namespace :: entity - identify names, if didn't add using namespace std
            std::cout, std::endl
    > namespace name_of_space{} - define a name space; any entiry inside brackets,
        will be bound to this namespace
    > using namespace name_of_space - used outside block affects
        the code after it till the end of source file; can add multiple, but
        should not lead to ambigious identfiers(same name in two scopes);
        if used inside block, ends in the same place that block does
    > namespace may be extended by defining it more than once, can also be placed
        in separate files
    > using name_of_space::entity - introduce just one entity from a namespace;
        can't cause ambiguity
    > namespace {} - anonymous namespace; implicitly and automaticly used in a
        source file wher eits definition is visible
    > namespace new_name = old_name - namespace aliasing; assigning new name to
        a newspace, both names are valid; only recognized in the source file
        where the act of renaming has occured; should be placed after definition
        (cant be inline with definition)