Overloading operators - basics
    > classification:
        - unary, binary, ternary
        - prefix, postfix, infix
    > in C++ it is possible to overload existing operators (can create new), but
        cant redifine existing meaning
    > operator function may be implemented as:
        - method of a class - implicitly assumed that an object of that class is
            one of the required operator's arguments
        - "standalone" - function must explicitly specify the types of its
            arguments
    > [return_type] operator[operator] (argument) - operator overloading, first 
        word is a keyword, second is one of existing operators is C++(must be 
        glued together); stack push method as operator example:
            void Stack::operator<< (int v) throw (stack_overflow) - should be
                able to throw the same type of exception as the method it uses
                inside
    > to make a chained call possible (like values passed to cout) return the
        reference to the object; in stack example it is:
            Stack& operator>> (int v) throw(stack_overflow);
    > to make same stuff as above without touching source code of the class,
        add a standalone operator definition my specifying a reference to an
        object of the class as the first argument

Enumerated types
    > declaration:
        enum weekday {SUNDAY, MONDAY, TUESDAY...} - name of enumerator is weekday,
            compiler assigned values from 0 to 6 (also implicitly promoted to int,
            when used in context requiring integral values - '+', '-' operators)
    > in order to assign a value to variable of type enum you need to cast by
        one of the following ways(data will be lost):
            weekday day = static_cast<weekday>(0);
            weekday day = (weekday)0;
    > to assign custom values add equal sign followed by a value, need to specify
        first two - the following will be assumed:
            enum Symbols {ALPHA = -1, BETA = 1, GAMMA};
    > more than one value may be assigned the same value, example (A and C = 1):
        enum letters {A = 1, B = 0, C, D};
    > all values must be unique(even if assigned the same value)
    > enum type symbols must be unique across a namespace - one solution may be
        to put two enums in different classes
    > overloading a plus operator so it acts accordingly for weekdays enum:
        enum weekday {SUNDAY, MONDAY, TUESDAY, WEDNESDAY...};
        weekday operator+(weekday day, int days) {
            return weekday((int(day) + days) % 7);
        }

Overloading operators in detail
    > number of arguments in strict based on context overloading is used:
        - global (standalone) function - 1 or 2 arguments (unary or binary)
        - class method - 0 or 1 arguments (object of the class is recignized as
            one of the required arguments - usually the left one)
    > can't:
        - define new operators
        - change priority of the redefined operators
        - overload operators working with standard data types
    > overloadable operators:
        1. + - * / % - all binary, may be both implemented in global and member
            function
        2. ^ | & ~ << >> - all binary, except ~; may be both implemented in
            global and member function
        3. = - can only be implemented as a method and return a reference to an
            object or l-value in general
        4. == != > >= < <= - all binary, may be both implemented in global and
            member function; return value is boolean; overloading one of them
            doesn't cause any effect on another
        5. ! && || - binary, except ! - may be both implemented in global and
            member function; return type is boolean; the original operators use
            use short-cut evaluation tactic - ommit the evaluation of the right 
            argument if left one is sufficient to determine final result - means
            if arguments are function, right one might not be invoked at all;
            overloaded logical functions cant make such a distinction
        6. += -= *= %= /= &= |= ^= >>= <<= - can only be implemented as methods,
            return a reference to an object or an l-value in general; non of
            them are implicitly derived from regular counterparts (overloading
            + has no effect on +=); have only one argument and directly modify
            home object; should return a reference to the modified object to
            allow chaining
        7. ++ -- - (prefix) can only be implemented as methods and return
            a reference to  an object or an l-value in general; has to be
            implemeted as parameterless and return a reference to the modified
            object
        8. ++ -- - (postfix) same as prefix, but has to be implemeted as
            one-parameter function, so that compiler can distinguish between
            prefix and postfix; should return unmodified object (since postfix
            has effect after operations are performed)
        9. [] - can only be implemented as methods and return a reference to 
            an object or an l-value in general; not commutative anymore, may
            accept indexes when they are not integers, ints can be negative,
            operator needs to find a reference to the data; has to be declared
            as one-parameter operator - index comes from outside, object is the
            second argument
        10. () - can only be implemented as methods and return any value, any
            number of parameters, one class may have more than one overloaded
            operator () function
        11. & * - may be both implemented in global and member function; return
            any type; used to create pseudo-pointers (small pointers);
        12. more like ',', ->, new, new[], delete, delete[], typename
    > non-overloadable: ?:, ., ::, sizeof