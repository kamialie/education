Basic concepts of objective programming
    > define a class:
        class OurClass:
            pass
    > creating an object:
        object = OurClass()

From procedual to object-oriented approach
    > constructor has a name of __init__ and should always have at least one
        parameter (self - its a convention); also created a variable i and
        assigned it a value of 1:
            class Class:
                def __init__(self):
                    self.i = 1 
    > to create and assign a value to a property specify it on the constructor:
        def __init__(self):
            self.i = 1
    > to create a private property preceed it with 2 underscores:
        def __init__(self):
            self.__i = 1
    > every method must have self as its first parameter in order to access
        object's properties(Python implicitly sends the current object as the
        first argument)
    > define a sub-class:
        class SubClass(Class):
            pass
    > have to explicitly invoke a superclass' constructor
        class SubClass(Class):
            def __init__(self):
                Class.__init__(self)
    > invoking a method outside the class never requires to put self argument,
        but invoking from within the class does(also has to be put first)
    > to override a method and add extra functionality write a new one and call
        parent class's method inside it as well:
            def method(self, val)
                self.__i += val
                Class.method(self, val)

Properties
    > instance variables can be created at any time of object's life (not only
        initialization(constructor)) and be removed at any time
    > each object get a set of predefined properties:
        - __dict__ - contains the names and values of all the properties the
            object is currently carrying(dictionary is the output)
    > When instance variable is created inside any of the object's methods
        (including constructor), Python mangles the name - puts one underscore
        and class name before the name of the property(only with private variables),
        that is __First variable become _Class__First; second name is fully
        accessible from outside; mangling doesn't work when property is created
        on the fly - object.__property = 1, and is accessible by its name like
        ordinary property
    > class variable exists inside a class and outside any object(mangling has
        the same effect); aren't shown in __dict__:
            class Class:
                i = 0
                def __init__(self):
                    pass
    > hasattr() - function that takes 2 arguments: class or object, name of
        property(has to be passed as a string); returns True or False;
        returns True on class's attribute when invoked on the object of that
        class, even though its not listed in __dict__
    > getattr() - function that takes 2 arguments: object and its property name
        (as a string) and returns its current value
    > isinstance()
    > setattr() - function that takes 3 arguments: object, property name, new
        value

Methods
    > self (convention) must be the first parameter in all methods - it is used
        to obtain reference to object's instance and class variables and other
        methods
    > __init__ can not return a value, cannot be invoked directly either from
        the object or from inside the class
    > mangling works just like with properties
    > predifined attributes:
        - __name__ - string containing name of the class(object's doesnt have it);
            type(object) - return class which has been used to instantiate
            the object
        - __module__ - string containing name of the module which contains the
            definition of the class(module named __main__ means module currently)
            being run
        - __bases__ - tuple containing classes(not names) which are direct superclasses for
            for the class(the order is the same as that used inside the definition);
            objects don't have this attribute; class without explicit
            superclass point to object(predefined Python class) as its ancestor

Inheritance
    > __str__(self) - method that Python invokes when it needs to present
        object/class as a string (print(object) for example); predifine this
        method to get anything, result must be string:
        __str__(self):
            return "some string"
    > issubclass(class1, class2) - function that checks if class1 is a subclass
        of class2; returns True or False; each class is considered to be a
        subclass of itself
    > isinstance(object, class) - function that checks of an object is instance
        of the class; returns True or False; will return true when checking
        against parent class as well
    > is operator checks whether two variables refer to the same object
    > super() - function that returns the reference to parent class; no need to
        pass self argument as well; can be used to access variables/method of
        a parent class:
            class Sub(class):
                def __init__(self, name):
                    super().__init__(name)
    > Python looks for object components in the following order:
        1) inside objet itself
        2) in all classes involved in the object;s inheritance from botto to top
        3) if there us more than one class(multiple parents), Python scans from
            left to right(in the definition of the class)
        4) if both above fail, AttributeError exception is raised
    > any class method can be overwritten by its child(any method is implicitly
        virtual method)
    > Polymorphism - situation when a subclass can modify its superclass
        behaviour
    > Virtual method - redefined in any of the child classes
    > Inheritance - extends class's capabilities by adding new components and
        modifying existing ones; complete recipe is contained inside the class
        itself and all its ancestors; object makes use of all there attributes
    > Composition - project a class as a container able to store and use other
        object(derived from other classes) where each of the objects implements
        a part of desired behaviou

Exceptions
    > try-except-else-finally block - else goes after last except block (only
        one can be executed - either one of except branches or else block, thus
        else is executed when no exceptions were raised); finally block is
        always executed and goes last; else and finally are completely independant
        - can coexist or occur independantly:
            try:
                n = 1 / n
            except ZeroDivisionError:
                print("div failed")
                n = None
            else:
                print("everything is fine)
            finally:
                print("time to say goodbye")
                print(n)
    > exceptions are classes too, and the error message is produced by __str__()
        method
    > to get additional info abotu exception object use the following clause:
        try:
            pass
        except Exception as e:
            print(e)
            print(e.__str__())
    > args - property introduced by BaseException class - tuple designed to
        gather all arguments passed to class constructor:
            def printargs(args):
                lng = len(args)
                if lng == 0:
                    print("")
                elif lng == 1:
                    print(args[0])
                else:
                    print(str(args))
            ...
            except Exception as e:
                printargs(e.args)
    > own exceptions can be created by deriving ot from one of the built-in
        exception classes. It is also possible to to build your own hierarchy
        (derive from any of the top exception classes, like Exception)

Generators
    > piece of specialized code able to produce a series of values, and to
        control the iteration process
    > generators returns series of values, and implicitly invoked more than
        once
    > iterator protocol - a way in which an object should behave to conform to
        the rules imposed by the context of for and in statements; iterator
        must provide two methods:
            1) __iter__() - returns object itself and is invoked once(for Python
                to successfuly start the iteration)
            2) __next__() - intendent to return the next value of the desired
                series; will be invoked by the for/in statements in order to pass
                through the next iteration; method should raise StopIteration
                exception, if there are no more values to provide
    > iterator (being object of a class itself) can also be a part of another
        class; in order to use iterator than class should return this iterator
        on __iter__ invocation
    > yield - works as return for iterators; provides the values of the expression
        and doesn't lose the state of the function; all variables are frozen
        and will be resumed on the next invocation; should not be invoced
        explicitely, as it is a generator object:
            def fun(n):
                for i in range(n):
                    yield n
            for v in fun(5):
                print(v)
    > generators may be used within list comprehensions; list() function can
        trasnfrom a series of subsequent generator invocation into a real list
        as well:
            lst = list(fun(5))
    > conditional expression  - way of selecting one of two different values
        based on the result of boolean expression(it is an operator, weird
        ternary operator):
            expression1 if condition else expression2
    > list comprehension plus conditional expression example:
        list = [1 if x % 2 == 0 else 0 for x in range(10)]
    > brackets make a comprehension, while parethesis make a generator -
        comprehension creates an actual list, that is can be iterated through by
        loop, while generator provides subsequent values
    > lambda - anonymous function(without a name); useful for one time
        use, can be assigned to variable as well:
            lambda parameters : expression
    > map() - function that applies the first argument(function) to all of its
        second argument's elements(list, tuple, generator, etc) and returns an
        iterator delivering all subsequent function results:
            map(function, list)
    > filter() - function (takes same arguments as map()) that filters the second
        argument based on directions from the function:
            filter(function, list)
    > closure - technique which allows the storing of values in spite of the fact
        that the context in which they were created does not exist anymore:
            def outer(par):
                loc = par
                def inner():
                    return loc
                return inner
            fun = outer(1)
            print(fun())
    > inner is outer's private tool - can be invoked only inside outer
    > functions returns during outer execution is called closure - can use inside
        environment as well as take outside values in a form of parameters
            