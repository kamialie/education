Using modules
    > file with definitions that are used in a scripts or in an interactive
        instance of the interpreter
    > to add module functions, variables, classes, etc into script:
        import module_name
    > to add more either state import smth on the next line, or specify next
        module after comma on the current line
    > nameplace - a space in which some names exist and the names dont conflict
        with each other
    > after import is done, names in that namespace become available, but they
        dont conflict with already existing names
    > access variable from module:
        math.pi
    > import entities precisely(only those specified are imported, can be now
        accessed without qualification, the later overwrites):
            from math import pi
    > alias imported modules name or entity:
       import module as alias 
       from module import name as alias, another_name as another_alias

Some useful modules
    > dir(module) - returns alphabetically sorted list containing all entities'
        names available in the module (module must be imported first as a whole)
    > random module
        - random() - produces a float number frmo the range (0.0, 1.0)
            including zero, excluding one
        - seed() - directrly set the generator's seed; if no paramenter - uses
            current time, otherwise integer value
        - randomrange(end), randomrange(beg, end), randomrange(beg, end, step) -
            random intergers from the range (excluding right side number)
        - randint(left, right) - random integer including right-side number
        - choice(sequence) - choses a random element
        - sample(sequence, elements_to_choose=1) - builds a list of consisting
            of random elements
    > platform module
        - platform() - shows all underlying layers in one glance; (1) - alternative
            names, (0,1) - brief form
        - machine() - generic name of processor
        - processor - real name of processor
        - system() - generic OS name
        - version() - OS version
        - python_implementation() - denotes Python implementation
        - python_version_tuple() - (major part version, minor part, patch level
            number)

Package
    > __pycache__ - folder that is created when module is imported(contains
        module_name.python_implementation-xy.pyc where x and y are version numbers);
        semu-compiled file for Python use, will be rebuilt if source file has
        been modified; modules are implicitly executed by Python once
    > __name__ - internal source file variable; File containing a module gets -
        __main__, while file where module was imported get the name of the module
    > preceding variable with an underscore shows module users not to modify it
        (only a convention)
    > doc-string - string (maybe a multiline) placed before any module
        instructions (including imports) that briefly explains the purpose
        and contents of the module
    > path variable in sys module contains paths to folders where Python is going
        to look for module to be imported (append or insert absolute or relative
        path to the folder)
    > __init__.py - this file should located in package folder (executed when
        any of the pachake's modules is imported); can be left empty unless
        special initialization is required
    > Python can use a zip file as a directory with modules

Errors
    > simply structure(if exception is raised in try block, it immidiately jumps
        into except block, otherwise except block is ignored):
            try:
                #do smth
            except:
                #do smth
    > catching particular exceptions:
            try:
                #do smth
            except exc1:
                #do smth
            except exc1:
                #do smth
            except:
                #do smth
    > only one branch can be executed; searched in the same order they appear
    > KeyboardInterrupt exception is raised when Ctrl-C

Anatomy of exceptions
    > 63 built-in exceptions
    > exceptions match their own branch, but can also be handled by more general
        branch - first one met satisfies the exception
    > to handle two or more exception the same way:
        try:
            #smth
        except(exc1, exc2):
            #smth
    > exceptions can cross function and modules, and travel through the invocation
        chain looking for a matching except clause able to handle it:
            def badfun(n):
                try:
                    return 1/n
                except ArithmeticError:
                    #do smth
                return None
            badfun(0)

            or

            def badfun(n):
                return 1/n
            
            try:
                badfun(0)
            except ArithmeticError:
                #do smth
    > raise exc - raises specified exception; without specified exception
        immidiately re-raises the same exception as currently handled (may be
        used inside except block only)
    > assert expression - if result of expression evaluates to True, non-zero
        value, non-empty string, or other value different than None, nothing
        happens, otherwise raises an exception named AssertionError

Some of the most useful exceptions
    1) BaseException<-Exception<-ArithmeticError - abstract exception including
        all exception caused by arithmetic operations like zero division or
        ivalid domain
    2) BaseException<-Exception<-AssertionError - concrete exception raised by
        assert instruction
    3) BaseException - most general (abstract) of all Python exceptions
    4) BaseException<-Exception - abstract exception including all exceptions
        caused by errors resulting from code malfunctions
    5) BaseException<-Exception<-LookupError<-IndexError - concrete exception
        raised when you try to access non-existent sequence's element
    6) BaseException<-KeyboardInterrupt - concrete exception raised when user
        uses keyboard shortcut to terminate a program's execution (Ctrl-C in
        most OSs); if handling this exception doesn't lead to program termination,
        the program continues its execution; not derived from exception class
    7) BaseException<-Exception<-LookupError - abstract exception including all
        exceptions resulting from invalid references to different collections
    8) BaseException<-Exception<-MemoryError - concrete exception raised when
        an operation cannot be complete due to a lack of free memory
    9) BaseException<-Exception<-ArithmeticError<-OverflowError - concrete
        exception raised when a number is too big to be successfully stored
    10) BaseException<-Exception<-StandardError<-ImportError - concrete
        exception raised when an import operation fails
    11) BaseException<-Exception<-LookupError<-KeyError - concrete exception
        raised when you try to access non-existant collection's element
        (dictionary)

Characters and strings
    > 

Nature of string in Python
    > 