Using modules
    > file with definitions that are used in a scripts or in an interactive
        instance of the interpreter
    > to add module functions, variables, classes, etc into script:
        import module_name
    > to add more either state import smth on the next line, or specify next
        module after comma on the current line
    > nameplace - a space in which some names exist and the names dont conflict
        with each other
    > after import is done, names in that namespace become available, but they
        dont conflict with already existing names
    > access variable from module:
        math.pi
    > import entities precisely(only those specified are imported, can be now
        accessed without qualification, the later overwrites):
            from math import pi
    > alias imported modules name or entity:
       import module as alias 
       from module import name as alias, another_name as another_alias

Some useful modules
    > dir(module) - returns alphabetically sorted list containing all entities'
        names available in the module (module must be imported first as a whole)
    > random module
        - random() - produces a float number frmo the range (0.0, 1.0)
            including zero, excluding one
        - seed() - directrly set the generator's seed; if no paramenter - uses
            current time, otherwise integer value
        - randomrange(end), randomrange(beg, end), randomrange(beg, end, step) -
            random intergers from the range (excluding right side number)
        - randint(left, right) - random integer including right-side number
        - choice(sequence) - choses a random element
        - sample(sequence, elements_to_choose=1) - builds a list of consisting
            of random elements
    > platform module
        - platform() - shows all underlying layers in one glance; (1) - alternative
            names, (0,1) - brief form
        - machine() - generic name of processor
        - processor - real name of processor
        - system() - generic OS name
        - version() - OS version
        - python_implementation() - denotes Python implementation
        - python_version_tuple() - (major part version, minor part, patch level
            number)

Package
    > __pycache__ - folder that is created when module is imported(contains
        module_name.python_implementation-xy.pyc where x and y are version numbers);
        semu-compiled file for Python use, will be rebuilt if source file has
        been modified; modules are implicitly executed by Python once
    > __name__ - internal source file variable; File containing a module gets -
        __main__, while file where module was imported get the name of the module
    > preceding variable with an underscore shows module users not to modify it
        (only a convention)
    > doc-string - string (maybe a multiline) placed before any module
        instructions (including imports) that briefly explains the purpose
        and contents of the module
    > path variable in sys module contains paths to folders where Python is going
        to look for module to be imported (append or insert absolute or relative
        path to the folder)
    > __init__.py - this file should located in package folder (executed when
        any of the pachake's modules is imported); can be left empty unless
        special initialization is required
    > Python can use a zip file as a directory with modules

Errors
    > simply structure(if exception is raised in try block, it immidiately jumps
        into except block, otherwise except block is ignored):
            try:
                #do smth
            except:
                #do smth
    > catching particular exceptions:
            try:
                #do smth
            except exc1:
                #do smth
            except exc1:
                #do smth
            except:
                #do smth
    > only one branch can be executed; searched in the same order they appear
    > KeyboardInterrupt exception is raised when Ctrl-C

Anatomy of exceptions
    > 63 built-in exceptions
    > exceptions match their own branch, but can also be handled by more general
        branch - first one met satisfies the exception
    > to handle two or more exception the same way:
        try:
            #smth
        except(exc1, exc2):
            #smth
    > exceptions can cross function and modules, and travel through the invocation
        chain looking for a matching except clause able to handle it:
            def badfun(n):
                try:
                    return 1/n
                except ArithmeticError:
                    #do smth
                return None
            badfun(0)

            or

            def badfun(n):
                return 1/n
            
            try:
                badfun(0)
            except ArithmeticError:
                #do smth
    > raise exc - raises specified exception; without specified exception
        immidiately re-raises the same exception as currently handled (may be
        used inside except block only)
    > assert expression - if result of expression evaluates to True, non-zero
        value, non-empty string, or other value different than None, nothing
        happens, otherwise raises an exception named AssertionError

Some of the most useful exceptions
    1) BaseException<-Exception<-ArithmeticError - abstract exception including
        all exception caused by arithmetic operations like zero division or
        ivalid domain
    2) BaseException<-Exception<-AssertionError - concrete exception raised by
        assert instruction
    3) BaseException - most general (abstract) of all Python exceptions
    4) BaseException<-Exception - abstract exception including all exceptions
        caused by errors resulting from code malfunctions
    5) BaseException<-Exception<-LookupError<-IndexError - concrete exception
        raised when you try to access non-existent sequence's element
    6) BaseException<-KeyboardInterrupt - concrete exception raised when user
        uses keyboard shortcut to terminate a program's execution (Ctrl-C in
        most OSs); if handling this exception doesn't lead to program termination,
        the program continues its execution; not derived from exception class
    7) BaseException<-Exception<-LookupError - abstract exception including all
        exceptions resulting from invalid references to different collections
    8) BaseException<-Exception<-MemoryError - concrete exception raised when
        an operation cannot be complete due to a lack of free memory
    9) BaseException<-Exception<-ArithmeticError<-OverflowError - concrete
        exception raised when a number is too big to be successfully stored
    10) BaseException<-Exception<-StandardError<-ImportError - concrete
        exception raised when an import operation fails
    11) BaseException<-Exception<-LookupError<-KeyError - concrete exception
        raised when you try to access non-existant collection's element
        (dictionary)

Characters and strings
    > 

Nature of string in Python
    > immutable sequence
    > multiline string start and ends with three apostrophes(or thriple quotes):
        string = '''line one
        line two'''
    > concatinate strings with '+' operator ('+=' is also permisslbe) - produces
        new string
    > replicate strings with '*' operator - needs number as second argument,
        order doesnt matter ('=*' is permisslbe)
    > ord() - as in ordinal; returns ANSI/UNICODE code point value, needs
        one-character string as its argument
    > chr() - inverse of the function above
    > slicing works the same as with lists
    > in operator checks if left argument appears anywhere in the right argument
        (string)
    > min() - function, find min according to ASCII(sequence can not be empty)
    > max() - same as above but max
    > index() - method searches the sequence from the beginning in order to find
        first appearance of specified argument(absence of argument will cause
        a ValueError exception)
    > list() - function, creates a new list given a string as an argument(also
        able to create lists from tuples, dictionaries...)
    > count() - method, counts occurences of the element inside sequence(absense
        of element doesnt raise exception)
    > more at https://docs.python.org/3.4/library/stdtypes.html#string-methods

String methods
    > capitalize() - creates new string and tries to apply the following rule
        - if the first element is a character(of the whole argument),
        capitalizes it and converts remaining to lower-case
    > center() - takes number(width) as its first argument and tries to center
        the string; second argument specifies what character to use instead of
        space
    > endswith() - checks if the given string ends with specified argument;
        returns True or False
    > find() - similar to index(), but safer; works with strings only; returns
        -1 if not found; second argument may specify where to start the search,
        third - where to end
    > isalnum() - parameterless, checks if the strnig contains only digits or
        alphabetical characters; returns True or False(empty string returns False)
    > isalpha() - letters only
    > isdigit() - digits only
    > islower() - lower-case isalpha() only
    > isspace() - only whitespace
    > isupper() - upper-case variant of islower()
    > join() - takes one argument - a list, whose elements must be strings,
        the string from which the method has been invoked is used as a separator
    > lower() - replaces all upper-case letters with their lower-case counterparts
    > lstrip() - removes all leading whitespaces; one argument version removes
        all character enlisted (in a string)
    > replace() - (2 parameter version) replaces all occurences of the first
        argument by the second one second argument can be empty string,
        first one can not; (3 paramenter version) uses the third argument
        to limit the number of replacements
    > rfint() - same as find(), but starts from the right side
    > rstrip() - right side version of lstrip()
    > split() - assumes that substring are delimited by whitespaces and returns
        a list of these substrings(empty string results in empty list)
    > startswith() - checks if string begins with specified parameter
    > strip() - combination of lstrip() and rstrip()
    > swapcase() - swaps the case of all letters (upper tp lower and vice versa)
    > title() - changes every word's first character to upper, the rest to lower
    > upper() - replaces all lower-case letter with upper-case

Strings in action
    > two strings are equal of both consists of the same characters in the same
        order
    > final relation is based on first different character
    > longer string is considered greater, if shorted is identical to longer's
        beginning
    > sorting lists:
        - sorted() - function, takes one argument, a list, and returns a new list
            filled with the sorted argument's elements
        - sort() - method, affect the list itself
    > conversions:
        - str(), int(), float() functions
        - conversion from string to integer only works, if a string represents
            a valid number, otherwise ValueError exception

> Four simple programs
    > https://en.wikipedia.org/wiki/International_Bank_Account_Number