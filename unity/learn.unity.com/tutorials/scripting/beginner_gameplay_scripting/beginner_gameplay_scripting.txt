1) scripts as behaviour components
    > change components of the object using user input, f.e.
        public class ExampleBehaviourScript : MonoBehaviour
        {
            void Update()
            {
                if (Input.GetKeyDown(KeyCode.R))
                {
                    GetComponent<Renderer> ().material.color = Color.red;
                }
                if (Input.GetKeyDown(KeyCode.G))
                {
                    GetComponent<Renderer>().material.color = Color.green;
                }
                if (Input.GetKeyDown(KeyCode.B))
                {
                    GetComponent<Renderer>().material.color = Color.blue;
                }
            }
        }

2) variables and functions
    >

3) conventions and syntax
    > dot operator
    > semicolon - terminate a statement
    > indenting
    > comments, multiple line example:
        /* example
         *
         *
         *
        */

4) score and access modifiers
    > default value of the public variable is overwritten by the value set in
        the inspector
    > variable setting in Start function (Update, so forth) overwrites the value
        in the inspector
    > default access modifier - private

5) Awake and Start
    > both called automatically when the script is loaded - run only once in a
        lifetime of the object
    > Awake is called first, even if the script component is not enabled - best
        for setting up references between scripts and initialization
    > Start is called after Awake immidiately before Update, but only when
        script component is enabled

6) Update and FixedUpdate
    > Update is called every frame(update interval times vary) - used mainly for
        moving non-physics objects, simple timers, receeing inputs
    > FixedUpdate is called every physics step (interval are consistent) - used
        for adjusting physics (rigidbody) objects
    > physics calculations are made immidiately after FixedUpdate

7) vector math
    > left hand rule coordinates - index finger pointing up is y axis, thumb
        would be x axis, middle finger point from you - z axis
    > useful methods:
        Vector3.Magnitude - returns magnitude of the vector
        Vector3.Dot
        Vector3.Cross
    > dot product = 0 - vectors are perpendicular (must have same origin)
    > cross vector - produces 3rd vector perpendicular to two given ones -
        direction of the resulting vector is based on left hand rule (vector A
            is thumb, vector B is index, resulting vector - pointing out middle)

8) enabling and disabling components
    > simple trigger for enabling / disabling object
        if (Input.GetKeyUp(KeyCode.Space)) 
            GameObject.enabled = !GameObject.enabled;
        }

9) activating GameObjects
    > set / unset object on the scene
        gameObject.SetActive(false); // or true
    > deactivating parent object deactivats child objects as well
    > check active state of the object
        gameObject.activeSelf
    > check active state of the hierarchy
        gameObject.activeInHierarchy

10) translate and rotate
    > move object along some line(Time.deltaTime makes object to move meters per
        second rather than meters per frame):
        public int moveSpeed;

        void Update()
        {
            transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);
        }
    > rotate object (pretty much the same as Translate):
        transform.Rotate(Vector3.up, turnSpeed * Time.deltaTime) // first
            argument is axis to apply rotation around
    > both work relative to local axis 
    > do not use for objects with colliders, rather use physics functions
    > only time to affect transform is for rigidbody that is kinematic

11) look at
    > make gameObject forward direction point to another transform in the world
        public Transform target; // give a reference to an object
        void Update()
        {
            transform.Lookat(target);
        }

12) linear interpolation
    > Lerp function takes 3 floats - from, to, how far
        float result = Mathf.Lerp(3f, 5f, 0.5f); // returns 4
    > Color.Lerp, Vector3.Lerp work just the same as Mathf version, just taking
        correspoding parameters
    >  smooth a value over time:
        void Update()
        {
            light.intensity = Mathf.Lerp(light.intensity, 8f, 0.5f); // add multiply the last argument by Time.deltaTime to make frame rate independent
        }
    > check SmoothDamp function

13) Destroy
    > can destroy object or its component; optinal second argument is a delay
    > doesn't make much sense to destroy object it is attached to as script gets
        destroyed as well; better use to get a reference to the object to destroy

14) GetButton and GetKey
    > GetKey represents exact keys on the keyboard, while geyButton is accesed
        by a string and cam be configured in Edit->Project settings->Input;
        It is recommended to use GetButton. Both function groups return boolean
    > three functions to check position(state) of a button or key:
        - GetButtonDown - return true on the first frame key is pressed
        - GetButton - returns true if key was pressed and stay same until Up is pressed
        - GetButtonUp - return true on the first frame key was released
        just the same for GetKey functions

15) GetAxis
    > represents virtual axis from the input
    > return value between -1 and 1
    > can be configured in Edit->Project settings->Input:
        - gravity - how fast it goes back to origin
        - sensitivity - how fast to go to target
        - dead - sensitivity of a joystick for example
        - snap - return 0 if both keys are pressed
    > f.e.
        public class GetAxisExample : MonoBehaviour
        {
            public float range;

            void Update()
            {
                float h = Input.GetAxis("Horizontal");
                float v = Input.GetAxis("Vertical");
                float xPos = h * range;
                float yPos = v * range;

                transform.position = new Vector3(xPos, yPos, 0);
            }
        }
    > GetAxisRaw only return 1 or 0 (therefore no need to configure gravity, etc)

16) OnMouseDown
    > detect a mouse click on the object on the scene
    > f.e.
        void OnMouseDown()
        {
            this.GetComponent<Rigidbody>().AddForce(-transform.forward * 500f);
            this.GetComponent<Rigidbody>().useGravity = true;
        }

17) GetComponent
    > object.GetComponent<Type>(); // object can be "this", other GameObject's
        reference
    > to access script put script name in Type field
    > pretty "expenive" call in terms of processing power - adviced to call on
        Awake or only once when its needed

18) DeltaTime
    > different frames might take different time to complete, thus motions and
        stuff changed based only on frames might not be smooth;
        Adding Time.deltaTime time to calculation makes motion take effect based on
        time rather than frames; deltaTime - returns difference between each call
        on Update of FixedUpdate

19) Data types
    > values types - int, float, char, struct...
    > reference types - transform, GameObject
    > f.e.
        void Start () 
        {
            //Value type variable
            Vector3 pos = transform.position; // creating a duplicate of the value
            pos = new Vector3(0, 2, 0);
            
            //Reference type variable
            Transform tran = transform; // creating another reference to object's transform
            tran.position = new Vector3(0, 2, 0);
        }

20) Classes
    > constructors must have the same name as a class, and never have a return
        type; Class can have multiple constructors (must have different prototypes)

21) Instanciate
    > just with one argument (object to instanciate) instanciates in object's default position
    > 3 function arguments are:
        - object to instanciate
        - where to instanciate
        - rotation (quaternion)
    > returns a type of object by default, thus add "as Type" to change that
        behaviour, f.e.:
        Rigidbody rocketInstance;
        rocketInstance = Instantiate(rocketPrefab, barrelEnd.position, barrelEnd.rotation) as Rigidbody;
        rocketInstance.AddForce(barrelEnd.forward * 5000);
    > good practive to add Destroy function to the objects created by Instanciate,
        as these object gonna stake in program's memory

22) Arrays
    > are fixed size, need to know length beforehand
    > GameObject.FindGameObjectsWithTag(); // returns an array

23) Invoke
    > lets you call a function after a delay, f.e.
        Invoke("functionName", delatInSeconds);
    > function invoked can only be of type void and without parameters
    > repeating Invoke, f.e.:
        InvokeRepeating("functionName", delatInSecondsBeforeFirstCall, delatInSecondsBeforeEachSubsequentCall);
    > stop invocation:
        CancelInvoke(); // can specify which function invocation to stop by passing string function name

24) Enumerations
    > can place both inside or outside of class
    > enum declaration:
        enum Direction {North, East, South, West};
    > Direction is considered as a type, whole line as a statement, thus a semicolon
    > each memeber is assigned an integer bu default
    > can specify number on each member (if specify on, following will eb incremented by one)
        enum Direction {North = 3, East, South, West};
    > can specify type:
        enum Direction : short {North = 3, East, South, West};
    > now can create a variable of this type and assign it a value
        Direction direction;
        direction = Direction.North;

25) Switch statements
    > f.e.:
        switch (variable)
        {
            case constant:
                //do smth
                break;
            case another_constant:
                //do smth
                break;
            default:
                //do smth
                break;
        }