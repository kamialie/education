File systems:
    > file names are case sensetive in Unix-like systems, but its not in Windows

Intro to files and streams
    > three basic modes to open the stream:
        - read - only read is allowed
        - write - only write is allowed
        - update - both read and write are allowed
    > stream types
        - text - structured in lines (character by character, line by line)
        - binary - sequence of bytes of any given value
    > different line ends marks:
        - \n - Unix
        - \r\n - Windows
    > translation of newline characters happend behind the scenes - each \n is 
        translated to \r\n when write happens, and vice versa when read happens

Opening streams
    > fopen() function
    > FILE *fopen(char *filename, char *openmode);
    > returns pointer to FILE variable or NULL on failure
    > open modes:
        - 'r' - read, file must exist and has to be readable
        - 'w' - write, doesn't need to exist; If doesn't exist, will be created,
            otherwise truncated to zero;
        - 'a' - append, doesn't need to exist, same as write, but append to the
            end, if existed
        - 'r+' - read and update, must exist and be writeable, otherwise fails;
            both read and write are allowed
        - 'w+' - write and update, same as 'w', also read is allowed
    > default is text mode, otherwise add b letter to the end to specify binary
    > have to specify 't' for Windows

Pre-opened streams
    > stdin - scanf reads from it by default
    > stdout - printf write to it
    > stderr

Closing the stream and error handling
    > fclose() function
    > int fclose(FILE *stream);
    > returns 0 on success
    > errno is located in errno.h - every function, programs sets it on failure
    > char *strerror(int errnum); - gets errnu and returns pointer to the text
        describing it

Reading from the stream
    > fgets() function 
    > int fgetc(FILE *stream); - attempts to ready one character from the stream
        and returns its code, otherwise -1, also on end of file
    > int getchar(void); - returns one character read from stdin
    > char *fgets(char *str, int maxsize, FILE *stream); - str is where to store,
        max number that can be safely stored(includes non-visible characters like
        '\0')
    > attempts to read one line
    > char *gets(char *str); same as previous but with INT_MAX and stdin
        parameters(doesnt check limitation, therefore dangerous)
    > int fread(void *mem, int size, int count, FILE *stream); - size (in bytes)
        to eb read, count (number of portions to be read); returns number of
        successfuly read portions, may or may not equal to count
    > int fscanf(FILE *steam, const char *format, ...); - more general scanf

Writing to the stream
    > int fputs(int chr, FILE *stream); - writes one characters to the stream
        int putchar(int chr) concrete function(writes to sdtout)
    > int fputs(char *string, FILE *stream); - on success returns non-negative
        value
    > int puts(char *string); - writes to stdout and appends a new line character
    > int fwrite(void *mem, int size, int count, FILE *stream); - same as
        fread, but write
    > int fprintf(FILE *stream, char *format);

Dealing with the steam's position
    > long ftell(FILE *stream); - returns distance in bytes from the beginning
        of the file to the current position
    > int fseek(FILE *stream, long offset, int whence); - sets the current
        postions of the file; offset (target postion, may be negative),
        whence (value indicating a reference point: SEEK_SET - from the beginning,
        SEEK_CUR - current position, SEEK_END - end of file)
    > void rewind(FILE *stream); - sets file head to the beginning(concrete
        function of fseek) - doesnt set errno
    > int feof(FILE *stream); - returns 0 if file isn't in EOF state

Bonus
    > pay attention when writing numbers to the stream - each digit is one
        byte
    > special case - fwrite writing from FILE *f - it is possible, as it
        write from some structure pointed by f
    > EOF has a value of -1