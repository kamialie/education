Preprocessor, absolute basics
    > gcc -E program.c - stop compiler right after preprocessor completes its job
        and sends output to stdout
    > preprocessor directive always begins with #

Include directive
    > if enclosed in quotes, searches in the current directory as the file
        containing the directive, otherwise searches in the compiler's default
        directory:
            #include <filename>
            #include "filename"

Define directive
    > define can take 3 forms:
        #define identifier text
        #define identifier(parameter_list) text
        #define identifier
    > with the first form preprocessor replaces every occurence of identifier
        with the text
    > properly written define needs paranthesis to ensure to order in which
        instructions will take place, as it just substitutes identifiers
        without analyzing their use
    > popular macros:
        #define NULL ((void *) 0)
        #define EOF (-1)
        #define SEEK_SET 0
        #define SEEK_CUR 1
        #define SEEK_END 2

Parameterized define directive
    > should consist of different pairwise identifiers (at least one), separated
        by commas:
            #define identifier(parameter_list) text
    > each macro parameter in text is replaced by the argument from the source
        code, then whole macro is replaced by the text composed

Thirt variant of define, and undefine
    > causes preprocessor to assume that the identifier is a defined identofier
        (that is known to the compliler):
            # define identifier
    > cancels the effects of the selected #define directive:
        #undef identifier

Predefined identifiers
    > __LINE__ - replaced by an integer literal equal to the line number, where
        the symbol appears
    > __FILE__ - replaced by the string literal containing the name of the source
        file (enclosed in quotes)
    > __DATE__ - replaced by a string literal containing text denoting the day
        the source file was compiled; contains exactly 11 characters
    > __TIME__ - replaced by a string literal containing text denoting the time
        (hours, minutes, seconds) the source file was compiled
    > __STDC__ - (as in Standard C) is defined only if compliler is operating in
        in compliance with the ANSI "C" standard

Operators
    > only act during the preprocessing phase and dissapear from the source code
        when preprocessor completes its work
    > '#' operator (not to confuse with '#' at the beginning of the directives)
        is a prefix unary operator that affects the macro during the expansion
        phase and causes its argument to be enclosed in a pair of quotes:
            #define QUOTE(X) "X" is same as #define QUOTE(X) #X
        first version is not going to work, as compiler doesn't look inside
        quotes
    > good example:
        #define SNAP(X) printf("variable "#X" = %d\n", X);
    > '##' binary operator that causes the text retrieved from arguments to be
        "glued" (concatenated); simply XY wont work, as it would be identified
        as XY parameter:
            #define GLUE(X, Y) X##Y

Conditional compilation
    > if #if directive is used, it must be ended by #endif directive too; between
        two directives any number of #elif directives can be placed and one #else
        expressions placed after #if and #elif will decide which of the texts
        will be passsed for further compilation
    > expressions can ve evaluated by means of:
        - preprocessor symbols that are assigned numberic values (using #define
            directives)
        - operators: +, -, *, /, >>, <<, >, <, >=, <=, ==, !=, %, &, &&, |, ||
        - sub-expressions enclosed in paretheses
        - pseudo-function named define, whose argument is a symbol and whose
            result is 1 of symbol is defined, otherwise 0
    > some of directives may be simplified:
        - if define(IDENT) == ifden IDENT
        - if !define(IDENT) == ifndef IDENT
    > value of expr0 is evaluated first and if its result is a non-zero, text0
        is passed to the compiler, other texts are ignored, otherwise next expr
        is evaluated:
            #if expr0
            text0
            #elif expr1
            text1
            #elif expr2
            text2
            #else
            text0
            #endif
    > gcc -D DEBUG file.c - defines DEBUG macro, which then can be used as follows:
        int i = smth
        #ifdef DEBUG
        SNAP(i)
        #endif
    > conditional compilation directives can be nested like ordinary conditional
        instructions
    > to avoid multiplied compilation (multiple header inclusion) check if a
        special individual identifier is already defined and ignore the rest of
        file if thats true, otherwise define this symbol:
            for header.h
            #ifndef __HEADER_H__
            #define __HEADER_H__
            #define SIZE 100
            #endif
    > widely accepted to derive this identifier from header file name:
        for header.h it would be __HEADER_H__

The scope of the declaration
    > range of the different scopes:
        - identifier declared outside function - extends from the point at
            which it was declared to the end of the module
        - identifier declared as function parameter - from the declaration to
            the end of the function body
        - within the function - from the declaration to the end of the block of
            the block in which the declaration
    > 3 types of linkage:
        - internal - each repeated identifier declaration inside one file denotes
            teh same object
        - external - each repeated identifier in the entire program denotes
            the same object
        - no linkage - every declaration describes a unique object
    > function defined in one module and having prototype in another has external
        linkage
    > external storage class specifier lets identifier be defined inside or
        outside of current module
    > hiding - for example two variable declarations in one function, one inside
        function, second inside another block in the same function - second
        declaration hides first one until block end

Storage classes
    > extern, static, register
    > extern int amount; - causes compiler to assume that a variable with the
        same name is defined in another module (like global variable); other
        variables declared as extern with the same name will be treated as
        references to the one and the same variable
    > static int counter; - variable declared inside a function will be brought
        to life when program starts and is destroyed when the program finishes;
        variable declared within module will only be accessible inside this
        module (even with extern linkage in another module)
    > static void fun(void){} - internal linkage, only accessible inside parent
        module
    > register int time; - let compiler know to store variable in processor
        registers (data is transferred several times faster)
    > register limitations:
        - variable size exceeds the maximum size
        - too many variables - compiler may accept only first few variables
            and silently ignore the rest(cause of limited number of registers)
        - variable declared as register can not be used as an argument to the
            unary & operator(cause it has no address)

Pointers to functions
    > float (*ptr)(float); - declaration of function pointer ptr
    >
        float cube(float x)
        {
            return x * x * x;
        }
        ptr = cube; - assigning address of cube function to ptr
    > general use to send a function as a function parameter:
        void printsmth(float (*fun)(float))
        {
            //do smth
        }
        printsmth(cube);

Complex declarations
    > generally a C language declaration takes the following form:
        T D;
        where T is a type, D is a declarator
    > T D - if D is just a simple identifier, D is an entity of type T
    > T D[n] - array of size n and type T
    > T * D - pointer to data of type T
    > T D() - function whose return value is of type T (has a higher priority
        than *)
    > break declaration into parts starting from the place where D is located

Bonus:
    > string literal can be broken at any point with the " character, and then
        any number of white characters may appear, after which, the literal may
        be resumed with another " character
    > remember that preprocessor macros JUST SUBSTITUTE text